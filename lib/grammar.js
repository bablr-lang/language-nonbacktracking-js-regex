/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#8e75e822dd72397930643b0b981729ac5b48893d
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
let _initProto, _FlagsDecs, _GroupDecs, _AssertionDecs, _StartOfInputAssertionDecs, _EndOfInputAssertionDecs, _WordBoundaryAssertionDecs, _GapDecs, _CharacterDecs, _CharacterClassDecs, _CharacterClassRangeDecs, _CharacterSetDecs, _AnyCharacterSetDecs, _DigitCharacterSetDecs, _SpaceCharacterSetDecs, _WordCharacterSetDecs, _QuantifierDecs, _AnyDecs, _KeywordDecs, _PunctuatorDecs;
import { re, spam as m } from '@bablr/boot';
import { Node, CoveredBy, InjectFrom, UnboundAttributes, AllowEmpty } from '@bablr/helpers/decorators';
import objectEntries from 'iter-tools-es/methods/object-entries';
import * as Shared from '@bablr/helpers/productions';
import { eat, eatMatch, match, holdForMatch, guard, bindAttribute, fail } from '@bablr/helpers/grammar';
import { buildString, buildBoolean, buildNumber, buildNullTag } from '@bablr/agast-vm-helpers';
export const canonicalURL = 'https://bablr.org/languages/core/en/bablr-regex-pattern';
export const dependencies = {};
const escapables = new Map(objectEntries({
  n: '\n',
  r: '\r',
  t: '\t',
  0: '\0'
}));
export const getCooked = (escapeNode, span, ctx) => {
  let cooked;
  const codeNode = escapeNode.get('code');
  const type = ctx.sourceTextFor(codeNode.get('typeToken'));
  const value = ctx.sourceTextFor(codeNode.get('value'));
  if (!type) {
    const match_ = ctx.sourceTextFor(codeNode);
    cooked = escapables.get(match_) || match_;
  } else if (type === 'u' || type === 'x') {
    cooked = parseInt(value, 16);
  } else {
    throw new Error();
  }
  return cooked.toString(10);
};
const flagCharacters = {
  global: 'g',
  ignoreCase: 'i',
  multiline: 'm',
  dotAll: 's',
  unicode: 'u',
  sticky: 'y'
};
const unique = flags => flags.length === new Set(flags).size;
const getSpecialPattern = span => {
  if (span === 'Pattern') {
    return re`/[*+{}[\]().^$|\n\\<>]/`;
  } else if (span === 'CharacterClass') {
    return re`/[\]\\]/`;
  } else {
    throw new Error('unknown span type for special pattern');
  }
};
export const grammar = class RegexGrammar {
  static {
    [_initProto] = _applyDecs(this, [[Node, 2, "Pattern"], [_FlagsDecs, 2, "Flags"], [AllowEmpty, 2, "Alternatives"], [[AllowEmpty, Node], 2, "Alternative"], [AllowEmpty, 2, "Elements"], [_GroupDecs, 2, "Group"], [Node, 2, "CapturingGroup"], [_AssertionDecs, 2, "Assertion"], [_StartOfInputAssertionDecs, 2, "StartOfInputAssertion"], [_EndOfInputAssertionDecs, 2, "EndOfInputAssertion"], [_WordBoundaryAssertionDecs, 2, "WordBoundaryAssertion"], [_GapDecs, 2, "Gap"], [_CharacterDecs, 2, "Character"], [_CharacterClassDecs, 2, "CharacterClass"], [_CharacterClassRangeDecs, 2, "CharacterClassRange"], [_CharacterSetDecs, 2, "CharacterSet"], [_AnyCharacterSetDecs, 2, "AnyCharacterSet"], [_DigitCharacterSetDecs, 2, "DigitCharacterSet"], [_SpaceCharacterSetDecs, 2, "SpaceCharacterSet"], [_WordCharacterSetDecs, 2, "WordCharacterSet"], [_QuantifierDecs, 2, "Quantifier"], [Node, 2, "UnsignedInteger"], [Node, 2, "EscapeSequence"], [Node, 2, "EscapeCode"], [Node, 2, "Digit"], [_AnyDecs, 2, "Any"], [_KeywordDecs, 2, "Keyword"], [_PunctuatorDecs, 2, "Punctuator"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_FlagsDecs = [UnboundAttributes(Object.keys(flagCharacters)), AllowEmpty, Node], _GroupDecs = [CoveredBy('Element'), Node], _AssertionDecs = CoveredBy('Element'), _StartOfInputAssertionDecs = [CoveredBy('Assertion'), Node], _EndOfInputAssertionDecs = [CoveredBy('Assertion'), Node], _WordBoundaryAssertionDecs = [UnboundAttributes(['negate']), CoveredBy('Assertion'), Node], _GapDecs = [CoveredBy('Assertion'), Node], _CharacterDecs = [CoveredBy('Element'), CoveredBy('CharacterClassElement'), Node], _CharacterClassDecs = [UnboundAttributes(['negate']), CoveredBy('Element'), Node], _CharacterClassRangeDecs = [CoveredBy('CharacterClassElement'), Node], _CharacterSetDecs = CoveredBy('Element'), _AnyCharacterSetDecs = [CoveredBy('CharacterSet'), Node], _DigitCharacterSetDecs = [UnboundAttributes(['negate']), CoveredBy('CharacterSet'), Node], _SpaceCharacterSetDecs = [UnboundAttributes(['negate']), CoveredBy('CharacterSet'), Node], _WordCharacterSetDecs = [UnboundAttributes(['negate']), CoveredBy('CharacterSet'), Node], _QuantifierDecs = [UnboundAttributes(['min', 'max']), Node], _AnyDecs = InjectFrom(Shared), _KeywordDecs = [Node, InjectFrom(Shared)], _PunctuatorDecs = [Node, InjectFrom(Shared)], "Pattern")]() {
    yield eat(m`openToken: <*Punctuator '/' balanced='/' balancedSpan='Pattern' />`);
    yield eat(m`<Alternatives />`);
    yield eat(m`closeToken: <*Punctuator '/' balancer />`);
    yield eat(m`flags$: <Flags />`);
  }
  *Flags({
    ctx
  }) {
    const flags = yield match(re`/[gimsuy]+/`);
    const flagsStr = ctx.sourceTextFor(flags) || '';
    if (flagsStr && !unique(flagsStr)) throw new Error('flags must be unique');
    for (const {
      0: name,
      1: chr
    } of Object.entries(flagCharacters)) {
      if (flagsStr.includes(chr)) {
        yield bindAttribute(buildString(name), true);
      } else {
        yield bindAttribute(buildString(name), false);
      }
    }
    for (const flagChr of flagsStr) {
      yield eat(m`tokens[]: <*Keyword ${buildString(flagChr)} />`);
    }
  }
  *Alternatives() {
    do {
      yield eat(m`alternatives[]$: <Alternative />`);
    } while (yield eatMatch(m`separators[]: <*Punctuator '|' />`));
  }
  *Alternative() {
    yield eat(m`elements[]$: <Elements />`);
  }
  *Elements() {
    yield eat(m`.[]: []`);
    while (yield match(re`/[^|]/`)) {
      yield eat(m`.[]: <Element />`);
    }
  }
  *Element() {
    yield guard(m`<*Keyword /[*+?]/ />`);
    yield eat(m`.+: <Any />`, [m`<CharacterClass '[' />`, m`<Group '(?:' />`, m`<Assertion /[$^]|\\b/i />`, m`<Gap '\\g' />`, m`<CharacterSet /\.|\\[dswp]/i />`, m`<*Character />`]);
    if (yield match(re`/[*+?{]/`)) {
      return holdForMatch(m`<Quantifier />`);
    }
  }
  *Group() {
    yield eat(m`openToken: <*Punctuator '(?:' balanced=')' />`);
    yield eat(m`<Alternatives />`);
    yield eat(m`closeToken: <*Punctuator ')' balancer />`);
  }
  *CapturingGroup() {
    yield eat(m`openToken: <*Punctuator '(' balanced=')' />`);
    yield eat(m`<Alternatives />`);
    yield eat(m`closeToken: <*Punctuator ')' balancer />`);
  }
  *Assertion() {
    yield eat(m`<Any />`, [m`<*StartOfInputAssertion '^' />`, m`<*EndOfInputAssertion '$' />`, m`<*WordBoundaryAssertion /\\b/i />`]);
  }
  *StartOfInputAssertion() {
    yield eat(m`sigilToken: <*Keyword '^' />`);
  }
  *EndOfInputAssertion() {
    yield eatMatch(m`sigilToken: <*Keyword '$' />`);
  }
  *WordBoundaryAssertion({
    ctx
  }) {
    yield eatMatch(m`escapeToken: <*Punctuator '\\' />`);
    const m = yield eat(m`value: <*Keyword /b/i />`);
    yield bindAttribute('negate', buildBoolean(ctx.sourceTextFor(m) === 'B'));
  }
  *Gap() {
    yield eatMatch(m`escapeToken: <*Punctuator '\\' />`);
    yield eat(m`value: <*Keyword 'g' />`);
  }
  *Character() {
    if (yield match('\\')) {
      yield eat(m`@: <EscapeSequence />`);
    } else {
      yield eat(re`/[^\r\n\t]/`);
    }
  }
  *CharacterClass() {
    yield eat(m`openToken: <*Punctuator '[' balancedSpan='CharacterClass' balanced=']' />`);
    let negate = yield eatMatch(m`negateToken: <*Keyword '^' />`);
    yield bindAttribute('negate', !!negate);
    while (yield match(re`/./s`)) {
      yield eat(m`elements[]+$: <CharacterClassElement />`);
    }
    yield eat(m`closeToken: <*Punctuator ']' balancer />`);
  }
  *CharacterClassElement() {
    yield eat(m`<Any />`, [m`.: <CharacterSet /\\[dswp]/i />`, m`.: <Gap '\\g' />`, m`.+: <*Character />`]);
    if (yield match('-')) {
      return holdForMatch(m`.+: <CharacterClassRange />`);
    }
  }
  *CharacterClassRange() {
    yield eat(m`min+$: <*Character />`);
    yield eat(m`sigilToken: <*Punctuator '-' />`);
    yield eat(m`max+$: <*Character />`);
  }
  *CharacterSet() {
    yield eat(m`.+: <Any />`, [m`<AnyCharacterSet '.' />`, m`<DigitCharacterSet /\\[dD]/  />`, m`<SpaceCharacterSet /\\[sS]/  />`, m`<WordCharacterSet /\\[wW]/  />`]);
  }
  *AnyCharacterSet() {
    yield eat(m`sigilToken: <*Keyword '.' />`);
  }
  *DigitCharacterSet({
    ctx
  }) {
    yield eat(m`escapeToken: <*Punctuator '\\' />`);
    let code = yield eat(m`value: <*Keyword /[dD]/ />`);
    yield bindAttribute('negate', buildBoolean(ctx.sourceTextFor(code) === 'D'));
  }
  *SpaceCharacterSet({
    ctx
  }) {
    yield eat(m`escapeToken: <*Punctuator '\\' />`);
    let code = yield eat(m`value: <*Keyword /[sS]/ />`);
    yield bindAttribute('negate', buildBoolean(ctx.sourceTextFor(code) === 'S'));
  }
  *WordCharacterSet({
    ctx
  }) {
    yield eat(m`escapeToken: <*Punctuator '\\' />`);
    let code = yield eat(m`value: <*Keyword /[wW]/ />`);
    yield bindAttribute('negate', buildBoolean(ctx.sourceTextFor(code) === 'W'));
  }
  *Quantifier({
    ctx
  }) {
    yield eat(m`element+$: <Element />`);
    let attrs, sigil;
    if (sigil = yield eatMatch(m`sigilToken: <*Keyword /[*+?]/ />`)) {
      switch (ctx.sourceTextFor(sigil)) {
        case '*':
          attrs = {
            min: 0,
            max: Infinity
          };
          break;
        case '+':
          attrs = {
            min: 1,
            max: Infinity
          };
          break;
        case '?':
          attrs = {
            min: 0,
            max: 1
          };
          break;
      }
    } else if (yield eat(m`openToken: <*Punctuator '{' balanced='}' />`)) {
      let max;
      let min = yield eat(m`min$: <*UnsignedInteger />`);
      if (yield eatMatch(m`separator: <*Punctuator ',' />`)) {
        max = yield eatMatch(m`max$: <*UnsignedInteger />`);
      }
      min = min && ctx.sourceTextFor(min);
      max = max && ctx.sourceTextFor(max);
      min = min && parseInt(min, 10);
      max = max && parseInt(max, 10);
      attrs = {
        min,
        max
      };
      yield eat(m`closeToken: <*Punctuator '}' balancer />`);
    }
    yield bindAttribute('min', attrs.min ? buildNumber(attrs.min) : buildNullTag());
    yield bindAttribute('max', attrs.max ? buildNumber(attrs.max) : buildNullTag());
  }
  *UnsignedInteger() {
    yield eat(re`/\d+/`);
  }
  *EscapeSequence({
    state,
    ctx,
    value: props
  }) {
    const parentSpan = state.span;
    yield eat(m`escape: <*Punctuator '\\' openSpan='Escape' />`);
    let match;
    if (match = yield match(re`/[\\/nrt0]/`)) {
      const match_ = ctx.sourceTextFor(match);
      yield eat(m`code: <*Keyword ${buildString(match_)} closeSpan='Escape' />`);
    } else if (match = yield match(getSpecialPattern(parentSpan, ctx.reifyExpression(props)))) {
      const match_ = ctx.sourceTextFor(match);
      yield eat(m`code: <*Keyword ${buildString(match_)} closeSpan='Escape' />`);
    } else if (yield match(re`/[ux]/`)) {
      yield eat(m`code: <EscapeCode closeSpan='Escape' />`);
    } else {
      yield fail();
    }
  }
  *EscapeCode() {
    if (yield eatMatch(m`type: <*Keyword 'u' />`)) {
      if (yield eatMatch(m`openToken: <*Punctuator '{' />`)) {
        yield eatMatch(m`value$: <*UnsignedInteger />`);
        yield eat(m`closeToken: <*Punctuator '}' />`);
      } else {
        yield eat(m`value$: <*UnsignedInteger /\d{4}/ />`);
        yield eat(m`closeToken: null`);
      }
    } else if (yield eatMatch(m`type: <*Keyword 'x' />`)) {
      yield eat(m`openToken: null`);
      yield eat(m`value$: <*UnsignedInteger /\d{2}/ />`);
      yield eat(m`closeToken: null`);
    }
  }
  *Digits() {
    while (yield eatMatch(m`<*Digit />`));
  }
  *Digit() {
    yield eat(re`/\d/`);
  }
  *Any() {}
  *Keyword() {}
  *Punctuator() {}
};